"Settings: app_name: str, admin_email: str, items_per_user: int. BaseSettings subclass for app configuration using environment variables. get_settings() -> Settings. Dependency to retrieve settings, cached with @lru_cache. info(settings: Settings) -> dict. Returns app info using settings. Supports .env files via model_config = SettingsConfigDict(env_file=\".env\"). HTTP Basic Auth: Implements HTTP Basic Authentication. HTTPBasic(): Creates a security scheme for HTTP Basic Auth. HTTPBasicCredentials: Object containing username and password. security = HTTPBasic(): Initializes HTTP Basic security scheme. @app.get(\"/users/me\"): Path operation secured with HTTP Basic Auth. def read_current_user(credentials: Annotated[HTTPBasicCredentials, Depends(security)]): Requires valid HTTP Basic credentials. secrets.compare_digest(a, b): Securely compares strings to prevent timing attacks. HTTPException(status_code=401, detail=\"Incorrect username or password\", headers={\"WWW-Authenticate\": \"Basic\"}): Returns 401 error with WWW-Authenticate header. def get_current_username(credentials: Annotated[HTTPBasicCredentials, Depends(security)]): Dependency to validate username and password. Testing Dependencies: Override dependencies during testing using app.dependency_overrides. Example: app.dependency_overrides[original_dependency] = override_dependency. Reset overrides: app.dependency_overrides = {}. Set/reset overrides within test functions for specific tests. from fastapi import Depends, FastAPI; from fastapi.testclient import TestClient; app = FastAPI(); async def common_parameters(q: str | None = None, skip: int = 0, limit: int = 100): return {\"q\": q, \"skip\": skip, \"limit\": limit}; @app.get(\"/items/\") async def read_items(commons: dict = Depends(common_parameters)): return {\"message\": \"Hello Items!\", \"params\": commons}; client = TestClient(app); async def override_dependency(q: str | None = None): return {\"q\": q, \"skip\": 5, \"limit\": 10}; app.dependency_overrides[common_parameters] = override_dependency; def test_override_in_items(): response = client.get(\"/items/\"); assert response.status_code == 200 Response Cookies: Use Response parameter in path operation to set cookies. Example: from fastapi import FastAPI, Response; app = FastAPI(); @app.post(\"/cookie-and-object/\") def create_cookie(response: Response): response.set_cookie(key=\"fakesession\", value=\"fake-cookie-session-value\"); return {\"message\": \"Come to the dark side, we have cookies\"}. Return Response directly: Create a response, set cookies, return it. Example: from fastapi import FastAPI, Response, JSONResponse; app = FastAPI(); @app.post(\"/cookie/\") def create_cookie(): content = {\"message\": \"Come to the dark side, we have cookies\"}; response = JSONResponse(content=content); response.set_cookie(key=\"fakesession\", value=\"fake-cookie-session-value\"); return response. FastAPI uses starlette.responses. WebSockets: Install: pip install websockets. @app.websocket(path) async def endpoint(websocket: WebSocket): await websocket.accept() data = await websocket.receive_text() await websocket.send_text(f\"Message: {data}\") Use Depends, Security, Cookie, Header, Path, Query. WebSocketException: Raise instead of HTTPException for WebSockets. ConnectionManager: connect(websocket: WebSocket): adds websocket to active connections. disconnect(websocket: WebSocket): removes websocket. send_personal_message(message: str, websocket: WebSocket): sends message to one websocket. broadcast(message: str): sends to all connected websockets. WebSocketDisconnect: Raised when connection closes. Handle with try/except. Return a Response Directly: Return Response or subclass (e.g., JSONResponse) from path operation. FastAPI won't modify it. Use jsonable_encoder to convert data to JSON-compatible types before putting in a Response. Example: from fastapi import FastAPI, Response; app = FastAPI(); @app.get(\"/legacy/\") def get_legacy_data(): data = \"<xml><data>...</data></xml>\"; return Response(content=data, media_type=\"application/xml\") Response Headers. Use Response parameter: get_headers(response: Response): response.headers[\"X-Cat-Dog\"] = \"alone in the world\". Return Response directly: return JSONResponse(content=content, headers=headers). Custom Headers: use 'X-' prefix. CORS configurations needed for browser visibility: expose_headers. Custom Responses: Override default JSONResponse. Use `response_class` or return Response directly. `response_class` documents OpenAPI. Responses: `Response(content, status_code, headers, media_type)`, `HTMLResponse(content)`, `PlainTextResponse(content)`, `JSONResponse(content)`, `ORJSONResponse(content)`, `UJSONResponse(content)`, `RedirectResponse(url, status_code)`, `StreamingResponse(iterator, media_type)`, `FileResponse(path, filename, media_type, headers)`. `FastAPI(default_response_class=Response)` sets default. FastAPI OpenAPI spec enables client code generation. Tools: OpenAPI Generator, openapi-ts. Define models (e.g., Item BaseModel, ResponseMessage BaseModel) and path operations (create_item, get_items). Custom operation IDs for cleaner client method names using generate_unique_id_function. FastAPI: Web framework for building APIs with Python type hints. High performance, fast to code, production ready. app = FastAPI(): Creates a FastAPI application. @app.get(\"/\"): Defines a GET path operation for the root path. async def read_root(): Can be used with async def for asynchronous operations. @app.get(\"/items/{item_id}\"): Path with a parameter item_id. def read_item(item_id: int, q: Union[str, None] = None): item_id is a path parameter, q is an optional query parameter. class Item(BaseModel): Defines a request body model with Pydantic. @app.put(\"/items/{item_id}\"): PUT operation with a path parameter and request body. def update_item(item_id: int, item: Item): Updates an item. fastapi dev main.py: Runs the FastAPI app with Uvicorn, auto-reloads on changes. Dependencies: Starlette, Pydantic. Installation: pip install \"fastapi[standard]\". Token: access_token str token_type str TokenData: username str | None = None scopes list[str] = [] User: username str email str | None = None full_name str | None = None disabled bool | None = None UserInDB: hashed_password str pwd_context = CryptContext(schemes=[\"bcrypt\"], deprecated=\"auto\") oauth2_scheme = OAuth2PasswordBearer( tokenUrl=\"token\" scopes={\"me\": \"Read information about the current user.\" \"items\": \"Read items.\"}) app = FastAPI() def verify_password(plain_password hashed_password) def get_password_hash(password) def get_user(db username str) -> UserInDB: if username in db: user_dict = db[username] def authenticate_user(fake_db username str password str) -> bool: user = get_user(fake_db username) if not user: if not verify_password(password user.hashed_password): def create_access_token(data dict expires_delta timedelta | None = None) -> str: to_encode = data.copy() if expires_delta: expire = datetime.now(timezone.utc) + expires_delta else: expire = datetime.now(timezone.utc) + timedelta(minutes=15) to_encode.update({\"exp\": expire}) encoded_jwt = jwt.encode(to_encode SECRET_KEY algorithm=ALGORITHM) def get_current_user(security_scopes SecurityScopes token: Annotated[str Depends(oauth2_scheme)]) -> UserInDB: if security_scopes.scopes: authenticate_value = f'Bearer scope=\"{security_scopes.scope_str}\"' else: authenticate_value = \"Bearer\" credentials_exception = HTTPException(status_code=status.HTTP_401_UNAUTHORIZED detail=\"Could not validate credentials\" headers={\"WWW-Authenticate\": authenticate_value}) try: payload = jwt.decode(token SECRET_KEY algorithms=[ALGORITHM]) username: str = payload.get(\"sub\") if username is None: raise credentials_exception token_scopes = payload.get(\"scopes\" []) token_data = TokenData(scopes=token_scopes username=username) except (InvalidTokenError ValidationError): raise credentials_exception user = get_user(fake_users_db username=token_data.username) if user is None: raise credentials_exception for scope in security_scopes.scopes: if scope not in token_data.scopes: raise HTTPException(status_code=status.HTTP_401_UNAUTHORIZED detail=\"Not enough permissions\" headers={\"WWW-Authenticate\": authenticate_value}) return user def get_current_active_user(current_user: Annotated[User Security(get_current_user scopes=[\"me\"])]) -> User: if current_user.disabled: raise HTTPException(status_code=400 detail=\"Inactive user\") return current_user @app.post(\"/token\") async def login_for_access_token(form_data: Annotated[OAuth2PasswordRequestForm Depends()] -> Token: user = authenticate_user(fake_users_db form_data.username form_data.password) if not user: raise HTTPException(status_code=400 detail=\"Incorrect username or password\") access_token_expires = timedelta(minutes=ACCESS_TOKEN_EXPIRE_MINUTES) access_token = create_access_token(data={\"sub\": user.username \"scopes\": form_data.scopes} expires_delta=access_token_expires) return Token(access_token=access_token token_type=\"bearer\") @app.get(\"/users/me/\" response_model=User) async def read_users_me(current_user: Annotated[User Depends(get_current_active_user)]) -> User: return current_user @app.get(\"/users/me/items/\") async def read_own_items(current_user: Annotated[User Security(get_current_active_user scopes=[\"items\"])]) -> list: return [{\"item_id\": \"Foo\" \"owner\": current_user.username}] @app.get(\"/status/\") async def read_system_status(current_user: Annotated[User Depends(get_current_user)]) -> dict: return {\"status\": \"ok\"} FastAPI Lifespan Events: Define startup/shutdown logic with lifespan parameter in FastAPI app. lifespan(app: FastAPI) - async context manager function with yield. Executes code before yield on startup and after yield on shutdown. Alternative: @app.on_event(\"startup\") async def startup_event(): and @app.on_event(\"shutdown\") def shutdown_event():. Lifespan recommended. Events for main app only. Python Type Hints used by FastAPI for validation and documentation. Basic types: str, int, float, bool, bytes. Generic types from typing: List[type], Tuple[types], Set[type], Dict[key_type, value_type], Union[types], Optional[type], Annotated[type, metadata]. Function parameter type hint: def func(param: type) -> return_type:. Pydantic BaseModel uses type hints for data validation: class Model(BaseModel): field: type. JSONResponse allows returning custom HTTP status codes in FastAPI. Example: upsert_item(item_id str, name Optional[str], size Optional[int]) returns JSONResponse with status_code (e.g., status.HTTP_201_CREATED). OpenAPI Webhooks define server initiated requests. FastAPI documents webhooks in OpenAPI 3.1.0+. Use @app.webhooks.post(name) to define webhook handler. Example: @app.webhooks.post(\"event_name\") def handler(body: Model):. Webhook names are identifiers not paths. Models can be defined using Pydantic BaseModel. TestClient for testing WebSockets. Use client.websocket_connect(url) to connect. Methods: websocket.receive_json() -> dict, websocket.send_json(data: dict), websocket.close(). Example: with client.websocket_connect(\"/ws\") as websocket: data = websocket.receive_json(). Requires Starlette. WSGIMiddleware: Mount WSGI apps (Flask, Django). `from fastapi.middleware.wsgi import WSGIMiddleware`. `app.mount(path, WSGIMiddleware(wsgi_app))`. Example: Flask at /v1, FastAPI at /v2. Testing Events: startup - shutdown. Test event handlers using TestClient with a with statement. TestClient(app) context manager runs startup and shutdown events. Example: with TestClient(app) as client: client.get(\"/items/foo\"). FastAPI supports async/await for path operation functions. Use async def with await for I/O-bound operations. Use def for CPU-bound ops or if unsure. FastAPI handles both asynchronously. Concurrency is for I/O waiting; parallelism for CPU tasks. Coroutines are from async def. def functions run in threadpool. OpenAPI Callbacks: Document external API requirements for callback requests. APIRouter: Create router for callbacks. @invoices_callback_router.post(\"{$callback_url}/invoices/{$request.body.id}\", response_model=InvoiceEventReceived) def invoice_notification(body: InvoiceEvent): Defines callback path operation. Includes body and response models. Path can use OpenAPI 3 expressions with request parameters. @app.post(\"/invoices/\", callbacks=invoices_callback_router.routes) def create_invoice(invoice: Invoice, callback_url: Union[HttpUrl, None] = None): Main API endpoint, uses callbacks parameter to document external API. Example: callback_url = \"https://example.com/api/v1/invoices/events/\" httpx.post(callback_url, json={\"description\": \"Invoice paid\", \"paid\": True}) FastAPI Additional Responses: Use responses parameter in path operation decorators for additional OpenAPI responses. responses={status_code: {\"model\": Model, \"description\": \"...\", \"content\": {...}}}. model key defines response schema using Pydantic model. Example: responses={404: {\"model\": Message}}. Define additional media types in responses. Combine response_model, status_code, and responses. Reuse responses with dict unpacking. Behind a Proxy: Use root_path for proxy servers with path prefix. FastAPI(root_path=\"/api/v1\"). Command line option: --root-path /api/v1. Get current root_path: request.scope.get(\"root_path\"). Example: from fastapi import FastAPI, Request; app = FastAPI(); @app.get(\"/app\") def read_main(request: Request): return {\"message\": \"Hello World\", \"root_path\": request.scope.get(\"root_path\")}. Additional servers: servers=[{\"url\": \"...\", \"description\": \"...\"}], root_path=\"/api/v1\". Disable automatic server from root_path: root_path_in_servers=False. FastAPI internally uses root_path when mounting sub-applications."