"Modules: Files with their own scope, providing code availability to other files. ESM (ECMAScript Modules): Built-in module system with import/export. CommonJS (CJS): Module system using exports and require. TypeScript's Job: Prevent runtime errors by compile-time checks. Know the runtime environment (globals). Answer questions related to module loading, resolution, and transformation. Module: Compiler option to control output module format and inform module kind detection. Options: node16, nodenext, es2015, es2020, es2022, esnext, commonjs, system, amd, umd. Node.js Module Format Detection (node16/nodenext): .mjs: ESM, .cjs: CJS, .js: ESM if package.json has \"type\": \"module\", otherwise CJS. Input Module Syntax: ESM syntax (import/export) is common regardless of output format. verbatimModuleSyntax (TS 5.0): Requires input syntax to match output format. ESM/CJS Interoperability: Varies between runtimes, bundlers, and transpilers. Node.js: CJS cannot synchronously require ESM. esModuleInterop option affects interop rules. Module Specifiers: Emitted as-written, not transformed by compiler. Module Resolution: Host-defined process of finding files referenced by module specifiers. moduleResolution option specifies host's algorithm. Options: classic, node10, node16, nodenext, bundler. Declaration Files (.d.ts): Describe JavaScript files, used for type information. Compiler looks for .d.ts files first, then .ts files. Module Resolution for Bundlers/TypeScript Runtimes: noEmit and allowImportingTsExtensions: Allow .ts extensions in imports. Use bundler moduleResolution. Module Resolution for Libraries: Use \"module\": \"nodenext\" for maximum compatibility. Compiler Options: Flags and Types for TypeScript compilation. CLI Commands: --all: Show all options. --help: Show help. --init: Initialize tsconfig.json. --listFilesOnly: List files. --locale: Set language. --project: Compile project. --showConfig: Print config. --version: Print version. Build Options: --build: Build projects. --clean: Delete outputs. --dry: Show build. --force: Build all. --verbose: Enable verbose logging. Watch Options: --excludeDirectories: Remove directories. --excludeFiles: Remove files. --fallbackPolling: Polling method. --synchronousWatchDirectory: Sync directory watchers. --watch: Watch files. --watchDirectory: Directory watch method. --watchFile: File watch method. Compiler Flags (Examples): --allowArbitraryExtensions: Allow extensions. --allowImportingTsExtensions: Allow .ts extensions in imports. --allowJs: Allow JavaScript files. --allowSyntheticDefaultImports: Allow default imports. --allowUmdGlobalAccess: Allow UMD globals. --allowUnreachableCode: Disable unreachable code errors. --allowUnusedLabels: Disable unused label errors. --alwaysStrict: Always emit 'use strict'. --assumeChangesOnlyAffectDirectDependencies: Affect dependencies. --baseUrl: Base directory for module resolution. --checkJs: Enable JavaScript error reporting. --composite: Enable project references. --customConditions: Conditions for resolving imports. --declaration: Generate .d.ts files. --declarationDir: Output directory for .d.ts files. --declarationMap: Create sourcemaps for .d.ts files. --diagnostics: Output compiler performance. --disableReferencedProjectLoad: Reduce project loading. --disableSizeLimit: Remove JavaScript file size cap. --disableSolutionSearching: Opt out of project checking. --disableSourceOfProjectReferenceRedirect: Disable source files. --downlevelIteration: Emit verbose JavaScript for iteration. --emitBOM: Emit UTF-8 BOM. --emitDeclarationOnly: Output only .d.ts files. --emitDecoratorMetadata: Emit decorator metadata. --esModuleInterop: Emit JavaScript for CommonJS interop. --exactOptionalPropertyTypes: Interpret optional types. --experimentalDecorators: Enable experimental decorators. --explainFiles: Print included files. --extendedDiagnostics: Output compiler performance details. --forceConsistentCasingInFileNames: Ensure casing in imports. --generateCpuProfile: Emit CPU profile. --generateTrace: Generates an event trace. --importHelpers: Import helper functions from tslib. --importsNotUsedAsValues: Specify emit/checking behavior for imports. --incremental: Save .tsbuildinfo files. --inlineSourceMap: Include sourcemaps. --inlineSources: Include source code in sourcemaps. --isolatedDeclarations: Require annotation on exports. --isolatedModules: Ensure files can be transpiled safely. --jsx: JSX code generation. --jsxFactory: JSX factory function. --jsxFragmentFactory: JSX fragment reference. --jsxImportSource: Module specifier for JSX functions. --keyofStringsOnly: keyof returns strings only. --lib: Specify library declaration files. --listEmittedFiles: Print emitted files. --listFiles: Print files read during compilation. --mapRoot: Debugger map file location. --maxNodeModuleJsDepth: Max depth for checking JavaScript files. --module: Module code generation. --moduleDetection: File type detection method. --moduleResolution: Module resolution strategy. --moduleSuffixes: Suffixes to search when resolving a module. --newLine: Newline character. --noCheck: Disable full type checking. --noEmit: Disable emitting files. --noEmitHelpers: Disable helper function generation. --noEmitOnError: Disable emitting on errors. --noErrorTruncation: Disable truncating types in errors. --noFallthroughCasesInSwitch: Report fallthrough cases. --noImplicitAny: Report implicit any type errors. --noImplicitOverride: Require override modifier. --noImplicitReturns: Report missing return statements. --noImplicitThis: Report this type errors. --noImplicitUseStrict: Disable 'use strict'. --noLib: Disable including library files. --noPropertyAccessFromIndexSignature: Use indexed accessors. --noResolve: Disallow imports. --noStrictGenericChecks: Disable generic checks. --noUncheckedIndexedAccess: Add undefined to index access. --noUncheckedSideEffectImports: Check side effect imports. --noUnusedLocals: Report unused local variables. --noUnusedParameters: Report unused parameters. --out: Deprecated. Use outFile. --outDir: Output folder. --outFile: Bundle output file. --paths: Remap imports. --plugins: Specify language service plugins. --preserveConstEnums: Disable erasing const enums. --preserveSymlinks: Disable resolving symlinks. --preserveValueImports: Preserve unused imports. --preserveWatchOutput: Disable console wiping. --pretty: Enable color and formatting. --reactNamespace: React object for createElement. --removeComments: Disable emitting comments. --resolveJsonModule: Enable importing .json files. --resolvePackageJsonExports: Use package.json 'exports'. --resolvePackageJsonImports: Use package.json 'imports'. --rootDir: Root folder. --rootDirs: Treat multiple folders as one. --skipDefaultLibCheck: Skip default .d.ts type checking. --skipLibCheck: Skip all .d.ts type checking. --sourceMap: Create source map files. --sourceRoot: Root path for debuggers. --stopBuildOnErrors: Skip building downstream projects on error. --strict: Enable all strict type-checking options. --strictBindCallApply: Check bind/call/apply arguments. --strictBuiltinIteratorReturn: Iterator return type. --strictFunctionTypes: Check function assignment types. --strictNullChecks: Check null and undefined. --strictPropertyInitialization: Check uninitialized class properties. --stripInternal: Disable emitting @internal declarations. --suppressExcessPropertyErrors: Disable excess property errors. --suppressImplicitAnyIndexErrors: Suppress noImplicitAny index errors. --target: JavaScript language version. --traceResolution: Log moduleResolution paths. --tsBuildInfoFile: Store .tsbuildinfo file path. --typeRoots: Specify multiple folders for @types. --types: Specify type package names. --useDefineForClassFields: Emit ECMAScript-standard class fields. --useUnknownInCatchVariables: Default catch clause variables as unknown. --verbatimModuleSyntax: Do not transform imports/exports. Everyday Types: string, number, boolean; Array: number[]; any; Type Annotations: let myName: string = \"Alice\"; Functions: function greet(name: string); function getFavoriteNumber(): number; Function returning Promise: async function getFavoriteNumber(): Promise<number>; Object Types: function printCoord(pt: { x: number; y: number }); Optional Properties: function printName(obj: { first: string; last?: string }); Union Types: function printId(id: number | string); type Point = { x: number; y: number; }; Interfaces: interface Point { x: number; y: number; } Type Assertions: const myCanvas = document.getElementById(\"main_canvas\") as HTMLCanvasElement; Literal Types: function printText(s: string, alignment: \"left\" | \"right\" | \"center\"); null and undefined; Enums; bigint; symbol. Generics: Create reusable components. function identity(arg: T): T. Type variables: T. Generic types: let myIdentity: (arg: T) => T = identity;. Generic interfaces: interface GenericIdentityFn { (arg: T): T; }. Generic classes: class GenericNumber { zeroValue: T; add: (x: T, y: T) => T; }. Constraints: interface Lengthwise { length: number; }. function loggingIdentity(arg: T): T. Keyof constraints: function getProperty(obj: T, key: K): T[K]. Class Types: function create(c: { new (): T }): T { return new c(); }. Functions: basic building blocks. Function Type Expressions: (param: type) => returnType; describes function type. Example: (a: string) => void. Parameter name required but type optional (defaults to any). Type alias for function type: type FuncName = (param: type) => returnType. Call Signatures: describe callable objects with properties. Syntax: { description: string; (arg: type): returnType; }. Construct Signatures: describe constructor functions with 'new' keyword. Syntax: { new (arg: type): returnType; }. Can combine call and construct signatures in interfaces. Generic Functions: type parameters for relating input/output types. Example: function firstElement(arr: Type[]): Type | undefined. Type Inference: TypeScript automatically infers type parameters. Constraints: limit type parameters using 'extends'. Example: . Working with Constrained Values: ensure function returns same type as input, not just constraint type. Specifying Type Arguments: manually specify type parameters: functionCall(...). Guidelines for Generics: Push type parameters down, use fewer parameters, type parameters should appear twice. Optional Parameters: param?: type or param = defaultValue. Type becomes type | undefined. Optional Parameters in Callbacks: avoid optional callback parameters unless intended for function to be called without the argument. Function Overloads: multiple function signatures for different argument types/counts. Overload signatures followed by implementation signature. Implementation signature not directly callable. Overload signatures must be compatible with implementation. Prefer union types over overloads when possible. 'this' in Functions: declare 'this' type as first parameter in function body for explicit 'this' context. Use 'function' keyword, not arrow functions. void: return type for functions without explicit return value. Not same as undefined. object: non-primitive type. Not Object or {}. unknown: any value, but unsafe to use directly. Safer than any. never: functions that never return, throw error or terminate. Function: global type for all functions, unsafe any return type, avoid if possible, use () => void instead. Rest Parameters: ...param: type[]; allows variable number of arguments. Rest Arguments: ...array; spread syntax to pass array as multiple arguments. Parameter Destructuring: unpack object arguments. Syntax: function sum({ a, b }: { a: number; b: number }). Assignability of Functions: void return type in contextual typing allows functions to return values which are ignored, except for literal function definitions with void return type, which must not return anything. Object Types: Represent data grouping. Anonymous: function greet(person: { name: string; age: number }) { ... }. Interface: interface Person { name: string; age: number; }. Type Alias: type Person = { name: string; age: number; }. Optional Properties: interface PaintOptions { shape: Shape; xPos?: number; yPos?: number; }. Readonly Properties: interface SomeType { readonly prop: string; }. Index Signatures: Describe types of possible values when property names are unknown. interface StringArray { [index: number]: string; }. Excess Property Checks: Validate object more thoroughly when created/assigned. interface SquareConfig { color?: string; width?: number; [propName: string]: unknown; }. Extending Types: interface AddressWithUnit extends BasicAddress { unit: string; }. Intersection Types: Combine existing object types. type ColorfulCircle = Colorful & Circle;. Generic Object Types: interface Box<Type> { contents: Type; }. Array Type: Array<number> or number[]. ReadonlyArray Type: readonly string[]. Tuple Types: type StringNumberPair = [string, number]; Tuple types can have optional elements: type Either2dOr3d = [number, number, number?]; readonly Tuple Types: function doSomething(pair: readonly [string, number]) { ... }. Classes in TypeScript support ES2015 class syntax with type annotations. Class Members include Fields, Constructors, Methods, Getters/Setters, and Index Signatures. Fields: `class Point { x: number; y: number; }` declares public properties; optional type annotation; initializers allowed; `readonly` modifier. Constructors: `constructor(x = 0, y = 0)` similar to functions, no return type, call `super()` in derived classes. Methods: `scale(n: number): void` function properties with type annotations, access via `this`. Getters/Setters: `get prop(){}`, `set prop(v){}` accessors, readonly if only getter. Index Signatures: `[s: string]: type` for object-like indexing. Class Heritage: `implements Interface`, `extends BaseClass`. implements checks interface conformance. extends for inheritance. Overriding Methods: derived class methods can override base class methods, use `super.method()` to call base. Type-only Field Declarations: `declare field: Type` for type re-declaration without runtime effect. Member Visibility: `public` (default), `protected` (subclasses), `private` (within class). JavaScript private fields `#field` for hard privacy. Static Members: `static member`, class-level members, visibility modifiers, inherited. Static Blocks: `static {}` for initialization code. Generic Classes: `class Box{}`, type parameters, constraints, defaults. this in Classes: `this` context in methods. Arrow Functions: `method = () => {}` bind `this` lexically. this parameters: `method(this: MyClass){}` enforce `this` type. this Types: `method(): this` return type as current class type. this-based type guards: `method(): this is Type`. Parameter Properties: `constructor(public field: type)`. Class Expressions: `const MyClass = class{}`. Constructor Signatures: `InstanceType`. Abstract Classes: `abstract class Base{ abstract method(); }`, cannot be instantiated, subclasses must implement abstract members. Abstract Construct Signatures: `function greet(ctor: new()=>Base){}`. Class relationships are structural. JSDoc Reference: @type: primitive types, declared types, JSDoc @typedef, TypeScript syntax. Array types: number[], Array.<number>, Array<number>. Object literal types: { a: string, b: number }. Function types: Closure and TypeScript syntax. Casts: /** @type {number} */ (numberOrString). @param & @returns: Type syntax as @type. @typedef, @callback, and @param: Define complex types. @template: Generic types. @satisfies: Declares value implements a type. Classes: ES6 classes, constructor functions. Property Modifiers: @public, @private, @protected, @readonly. @override: override methods. @extends, @implements: Class extension and interface implementation. @constructor: for constructor functions. @this: specify the type of this. @deprecated, @see, @link. @enum: Create an object literal with specified type. @author. Unsupported patterns and tags listed. /// <reference path=\"...\" /> declares file dependencies. /// <reference types=\"...\" /> declares package dependencies. /// <reference lib=\"...\" /> includes built-in lib file. /// <reference no-default-lib=\"true\"/> excludes default lib. /// <amd-module name=\"...\"/> defines AMD module name. /// <amd-dependency path=\"...\"/> injects non-TS module dependency. preserve=\"true\" prevents compiler removal. Conditional Types: `T extends U ? X : Y`. Choose type based on condition. Useful with generics. NameOrId: `T extends number ? IdLabel : NameLabel`. Example of conditional type. createLabel(idOrName: T): NameOrId. Function using conditional type. MessageOf: `T extends { message: unknown } ? T[\"message\"] : never`. Extracts property type or never if missing. Flatten: `T extends any[] ? T[number] : T`. Flattens arrays. Infer: `T extends Array ? Item : T`. Deduce type within conditionals. GetReturnType: `T extends (...args: never[]) => infer R ? R : never`. Extracts function return type. Distributive Types: Conditional types distribute over unions. Non-Distributive: `[T] extends [any] ? T[] : never`. Prevents distribution. Classes: class ClassName { }. Constructor: constructor(params). Methods: methodName(params): returnType. Inheritance: class Derived extends Base { super(baseParams); }. Modifiers: public (default), private (internal), protected (internal+subclass). ECMAScript private fields: #fieldName. readonly: readonly propertyName. Parameter properties: constructor(modifier param: type). Accessors: get propertyName() { }, set propertyName(value) { }. Static Properties: static propertyName. Abstract Classes: abstract class AbstractClass { abstract abstractMethod(); }. Cannot instantiate abstract classes directly. Constructor functions: class name is also a type. Class can be used as interface. Enums: Define named constants. Numeric enums: enum Direction { Up = 1, Down, Left, Right, } String enums: enum Direction { Up = \"UP\", Down = \"DOWN\", Left = \"LEFT\", Right = \"RIGHT\", } const enums: const enum Enum { A = 1, B = A * 2, } can only use constant enum expressions and are removed during compilation. Awaited<Type> unwraps Promises. Partial<Type> sets all props of Type to optional. Required<Type> sets all props to required. Readonly<Type> sets all props to readonly. Record<Keys, Type> creates an object with keys from Keys and values from Type. Pick<Type, Keys> picks props from Type. Omit<Type, Keys> omits props from Type. Exclude<UnionType, ExcludedMembers> excludes members. Extract<Type, Union> extracts members. NonNullable<Type> excludes null and undefined. Parameters<Type> creates a tuple from function parameters. ConstructorParameters<Type> creates a tuple from constructor parameters. ReturnType<Type> gets function's return type. InstanceType<Type> gets instance type of a constructor. NoInfer<Type> blocks type inference. ThisParameterType<Type> extracts this parameter type. OmitThisParameter<Type> removes this parameter. ThisType<Type> is a marker for contextual 'this' type. String manipulation types: Uppercase<StringType>, Lowercase<StringType>, Capitalize<StringType>, Uncapitalize<StringType>. declare namespace: Defines types/values accessed by dot notation. declare function: Declares a function. declare var: Declares a variable. declare const: Declares a read-only variable. declare let: Declares a block-scoped variable. interface: Defines a type with properties. type alias: Creates a shorthand for a type. declare class: Describes a class or class-like object. Types: string, number, bigint, boolean, symbol, null, undefined, object, unknown, never. Function: function fn(x) { return x.flip(); } greet(person: string, date: Date): console.log(`Hello ${person}, today is ${date.toDateString()}!`); tsc --noEmitOnError hello.ts (prevents .js output on error) Migrating from JavaScript. Use tsconfig.json to manage project options. Example: { \"compilerOptions\": { \"outDir\": \"./built\", \"allowJs\": true, \"target\": \"es5\" }, \"include\": [\"./src/**/*\"] }. tsc compiles src to built. Rename .js to .ts or .tsx. Use noEmitOnError to prevent compilation on errors. Use import foo = require(\"foo\"); for CommonJS/AMD modules. npm install -S @types/lodash for declaration files. Use export function feedPets(pets) {} for module exports. Function overloads define multiple call signatures. interface Options { color: string; volume: number; }. Use any for flexible types, but lose type safety. Enable stricter checks like noImplicitAny, strictNullChecks, noImplicitThis. strictNullChecks: use number | null for nullable types. Postfix ! asserts non-null. Point.prototype.distanceFromOrigin = function (this: Point) { ... }; Template Literal Types: type World = \"world\"; type Greeting = \\`hello \\${World}\\`; type EmailLocaleIDs = \"welcome_email\" | \"email_heading\"; type FooterLocaleIDs = \"footer_title\" | \"footer_sendoff\"; type AllLocaleIDs = \\`\\${EmailLocaleIDs | FooterLocaleIDs}\\_id\\`; type Lang = \"en\" | \"ja\" | \"pt\"; type LocaleMessageIDs = \\`\\${Lang}\\_\\${AllLocaleIDs}\\`; type PropEventSource<Type> = { on(eventName: \\`\\${string & keyof Type}Changed\\`, callback: (newValue: any) => void): void; }; declare function makeWatchedObject<Type>(obj: Type): Type & PropEventSource<Type>; type PropEventSource<Type> = { on<Key extends string & keyof Type> (eventName: \\`\\${Key}Changed\\`, callback: (newValue: Type[Key]) => void): void; }; type Uppercase<StringType>: converts to uppercase; type Lowercase<StringType>: converts to lowercase; type Capitalize<StringType>: capitalizes first letter; type Uncapitalize<StringType>: uncapitalizes first letter. Decorators: Annotate/modify classes/members. Use @expression. Requires experimentalDecorators compiler option. Decorator Factories: function returning decorator expression. function color(value: string) { return function (target) { ... }; } Decorator Composition: Evaluated top-to-bottom, called bottom-to-top. Decorator Evaluation Order: Parameter, Method/Accessor/Property (instance), Parameter, Method/Accessor/Property (static), Parameter (constructor), Class. Class Decorators: Applied to class constructor. Can observe/modify/replace class definition. function sealed(constructor: Function) { Object.seal(constructor); Object.seal(constructor.prototype); } Method Decorators: Applied to Property Descriptor. Can observe/modify/replace method definition. Args: target, member name, descriptor. function enumerable(value: boolean) { return function (target: any, propertyKey: string, descriptor: PropertyDescriptor) { descriptor.enumerable = value; }; } Accessor Decorators: Applied to Property Descriptor. Args: target, member name, descriptor. Apply to first accessor (get or set). Property Decorators: Args: target, member name. No descriptor. Used to record metadata. Parameter Decorators: Args: target, member name, parameter index. Used to observe parameter declaration. Metadata: Reflect-metadata library for metadata API. Requires emitDecoratorMetadata compiler option. import \"reflect-metadata\"; function validate<T>(target: any, propertyKey: string, descriptor: TypedPropertyDescriptor<T>) { ... } Namespaces: Organize code, avoid name collisions. namespace Validation { export interface StringValidator { isAcceptable(s: string): boolean; } export class LettersOnlyValidator implements StringValidator { isAcceptable(s: string) { return lettersRegexp.test(s); } } } Split across files using reference tags. Use outFile or per-file compilation. Aliases: import q = x.y.z. Ambient Namespaces: Declare APIs of external libraries. Mixins: Combine partial classes. Use generics with class inheritance. type Constructor = new (...args: any[]) => {}; function Scale<TBase extends Constructor>(Base: TBase) { return class Scaling extends Base { _scale = 1; setScale(scale: number) { this._scale = scale; } get scale(): number { return this._scale; } }; } Functions: Named and anonymous functions. function add(x: number, y: number): number { return x + y; } let myAdd: (x: number, y: number) => number = function (x: number, y: number): number { return x + y; }; Optional parameters: function buildName(firstName: string, lastName?: string) { ... } lastName is optional. Optional params must follow required params. Default parameters: function buildName(firstName: string, lastName = \"Smith\") { ... } lastName defaults to \"Smith\". Rest parameters: function buildName(firstName: string, ...restOfName: string[]) { ... } Gathers arguments into an array. this: Variable set when a function is called. Arrow functions capture this where the function is created. interface Card { suit: string; card: number; } interface Deck { createCardPicker(this: Deck): () => Card; } this parameters: function f(this: void) {}. Used in callbacks. Overloads: Multiple function types for the same function. function pickCard(x: { suit: string; card: number }[]): number; function pickCard(x: number): { suit: string; card: number }; function pickCard(x: any): any { ... } Modules: ECMAScript & CommonJS syntax supported. TypeScript extensions: export type, interface, enum, namespace. Type-only imports/exports: import type, export type. import() types: type T = import('mod').Type. export= and import=require() for CommonJS. Ambient modules: declare module 'mod' { ... }. Pattern ambient modules: declare module '*.ext' { ... }. Module compiler option: node16/nodenext: Node.js ESM/CJS, format detection, interoperability. preserve: Bundler/Bun, keeps import/export syntax, moduleResolution bundler. es2015/2020/2022/esnext: ES modules, not for Node.js. commonjs: CJS modules, dynamic import() transformed. system: SystemJS. amd: AMD loaders. umd: AMD/CJS loaders. ModuleResolution compiler option: Controls module specifier to file resolution. Common features: extension substitution, relative/extensionless paths, directory modules, paths, baseUrl, node_modules lookup. package.json exports, typesVersions, main, types, imports, self-name imports. node16/nodenext: Node.js resolution, import/require algorithms, exports/imports conditions (import/require). bundler: Bundler resolution, CommonJS + Node.js features, exports/imports conditions (syntax based). node10: Legacy Node.js resolution. classic: Deprecated. paths: Override module resolution for bare specifiers. baseUrl: Base directory for bare specifier resolution. package.json exports: Controls package subpath exports, conditions. package.json typesVersions: Version-specific type definitions. package.json main/types: Package entry points. Do's and Don'ts: Types: Use number, string, boolean, symbol. Avoid Number, String, Boolean, Symbol, Object. Use object instead of Object. Generics: Avoid generics without using type parameter. any: Avoid unless migrating JavaScript. Use unknown when type unknown. Callbacks: Use void return for callbacks whose value ignored. Avoid optional parameters in callbacks unless truly optional. Overloads and Callbacks: Avoid separate overloads differing only on callback arity. Use single overload with max arity. Function Overloads Ordering: Specific overloads after general ones. Optional Parameters: Use optional parameters instead of overloads differing in trailing parameters. Union Types: Use union types instead of overloads differing by type in one argument position. Mapped Types: Generic types using keyof. OptionsFlags: Properties to boolean. Modifiers: readonly, ? (+/- prefixes). CreateMutable: -readonly. Concrete: -?. Key Remapping: 'as' clause. Getters: get prefix. RemoveKindField: Exclude keys. EventConfig: map unions. ExtractPII: checks pii:true. DOM Manipulation: HTMLElement type. TypeScript includes DOM API type definitions. HTMLElement is the backbone. Example: const app = document.getElementById(\"app\"); const p = document.createElement(\"p\"); p.textContent = \"Hello, World!\"; app?.appendChild(p); Document: Interface for global document variable. Document.getElementById(elementId: string): HTMLElement | null; Returns HTMLElement or null. Document.createElement(tagName: K, options?: ElementCreationOptions): HTMLElementTagNameMap[K]; Creates an HTML element. Node: Base interface for HTMLElements. Node.appendChild(newChild: T): T; Appends a child node. Children vs childNodes: children returns HTMLCollection of element children. childNodes returns NodeList including text nodes. querySelector(selectors: string): Element | null; querySelectorAll(selectors: string): NodeListOf; Selects DOM elements. MDN documentation provides additional details. Symbols: Primitive type for unique identifiers. Symbol(): creates unique symbol. Optional string key for description. Symbols are unique and immutable. Used as object property keys. unique symbol: subtype of symbol. Well-known Symbols: Built-in symbols for language behaviors. Symbol.asyncIterator, Symbol.hasInstance, Symbol.isConcatSpreadable, Symbol.iterator, Symbol.match, Symbol.replace, Symbol.search, Symbol.species, Symbol.split, Symbol.toPrimitive, Symbol.toStringTag, Symbol.unscopables. TypeScript: Superset of JavaScript with static typing. Types: inferred or explicitly defined (interfaces, types). Primitive types: boolean, bigint, null, number, string, symbol, undefined, any, unknown, never, void. Unions: type can be one of many types (e.g., type MyBool = true | false;). Generics: type variables for types (e.g., Array). Structural Type System: type checking based on shape, not declaration (duck typing)."